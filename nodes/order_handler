#!/usr/bin/env python3
#File for OrderHandler Node
#RKS

# Project imports
from final_project_mixotics.srv import Order, OrderResponse
from final_project_mixotics.srv import InventoryUpdate, InventoryUpdateRepsonse
from final_project_mixotics.srv import VerifyInstr, VerifyInstrResponse
from final_project_mixotics.srv import DrinkInstr, DrinkInstrRequest
from menu_utilities.enum_defs import InstrEnum, StoreRoomEnum
from menu_utilities.menu_parser import parse_menu_xml
# Python imports


# 3rd-party imports
import rospy

class OrderHandler:
    """
    ROS Node responsible for receiving customer orders, translating them into
    high-level commands for the robot, and passing commands to the robot. The 
    node also sorts command order for effciency, validates orders from 
    customers, and track status of orders

    SERVICES:
        process_order Order

        update_inventory InventoryUpdate

        verify_instr VerifyInstr

    CLIENTS:
        drink_instr DrinkInstr

    PARAMS:
        + filepath menu.xml ~ filepath to the current menu configuration file.
            The default is the 'config/menu.xml'
    """
    def __init__(self):
        """
        Constructor of ROS Node OrderHandler class. Creates all 3 services, 
        client, order trackers, and internal varibles
        
        Public member:
        filepath menu_path: Filepath to menu configuration
        """
        # init node
        rospy.init_node("order_handler")
        # Grab Parameters
        self.menu_path = rospy.get_param("/mixotics/menu_path", "/config/menu.xml")
        # Set up services
        self._order_service = rospy.Service('process_order', Order, self._handle_order_service)
        self._invUp_service = rospy.Service('update_inventory', InventoryUpdate, self._handle_invUp_service)
        self._verify_service = rospy.Service('verify_instr', VerifyInstr, self._handle_verify_service)
        # Set up clients
        self._cmd_client = rospy.ServiceProxy('drink_instr', DrinkInstr)
        # Parse Menu file
        self._menu_dict = parse_menu_xml(self.menu_path)
        # Build StoreRoom 
        self._storeroom = {}
        for item in self._menu_dict.keys():
            for ingredient in item.ingredients:
                if ingredient.value not in self._storeroom.keys():
                    self._storeroom[ingredient.value] = True
        # Init Instruction Queue
        self._instr_queue = []
        self._instr_counter = 1
        # Init Active Instruction
        self._active_instr = None
        self._active_complete = False
        # Init New_Orders Queue 
        self._new_orders = []
        self._new_order_num = 1 # Start orders at 1
        self._ORDER_LIMIT = 100 # Max number of simulatanous orders
        

        # Set up run rate and main function
        self._RATE = 20 # in Hz
        self._time_delta = 1./self._RATE
        rospy.Timer(rospy.Duration(self._time_delta), self.main_loop)
        rospy.spin()


    def _handle_order_service(self, req):
        """
        Validate new order and return order num
        TODO:Better Doc
        """
        valid_order = True
        error_str = ""
        for order in req.orders:
            if order not in self._menu_dict.keys():
                valid_order = False
                error_str += f"Drink {order} is not on menu\n"
                continue
            order_item = self._menu_dict[order]
            for ingredient in order_item.ingredients:
                if not self._storeroom[ingredient.value]:
                    valid_order = False
                    error_str += f"Drink {order} is not available, we are out of {ingredient}!\n"
        
        if valid_order:
            order_num = self._new_order_num
            self._new_order_num = (self._new_order_num  % self._ORDER_LIMIT) + 1
            msg = f"Thank you for ordering! Your order number is {order_num}"
            self._new_orders.append((order_num, req.orders))
            return OrderResponse(order_num=order_num, msg=msg)
        else:
            return OrderResponse(order_num=0, msg=error_str)


    def _handle_invUp_service(self, req):
        """
        Updates availability of ingredient
        TODO: Better Doc
        """
        self._storeroom[req.ingredient] = req.available
        return InventoryUpdateRepsonse()

    def _handle_verify_service(self, req):
        pass

    def _send_cmd(self, instr):
        rospy.wait_for_service("drink_instr")
        try:
            self._cmd_client(instr[0], instr[1])
        except rospy.ServiceException as e:
            print(f"Can't talk to robot")
            rospy.logerr(e)

    def main_loop(self):
        """
        Main Execution loop TODO:Better Doc
        """
        # Check if new_order is in
        if len(self._new_orders) > 0:
            # if new_order, process order queue
            self._instr_queue = self._parse_orders()
        # Check if active_order exist
        if self._active_instr is None:
            if len(self._instr_queue) > 0:
                instr_id = self._instr_counter
                self._instr_counter += 1
                self._active_instr = (instr_id, self._instr_queue.pop(0))
                self._active_complete = False
                self._send_cmd(self._active_instr)

        # Check if active_order is done
        # If done, send new active order
        if self._active_complete:
            if len(self._instr_queue) > 0:
                instr_id = self._instr_counter
                self._instr_counter += 1
                self._active_instr = (instr_id, self._instr_queue.pop(0))
                self._active_complete = False
                self._send_cmd(self._active_instr)
        # If done, check order num is served
        # TODO: If order num is done, announce order up
        pass


#Activate 'order_handler' node
def main():
    """
    Activation function for order handler
    """
    order_handler = OrderHandler()

# Main Execution loop
if __name__ == "__main__":
    try:
        main()
    #If something kills this node, have it die
    except rospy.ROSInterruptException:
        pass