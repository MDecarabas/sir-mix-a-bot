#!/usr/bin/env python3
#File for OrderHandler Node
#RKS

# Project imports
from final_project_mixotics.srv import Order, OrderResponse
from final_project_mixotics.srv import InventoryUpdate, InventoryUpdateRepsonse
from final_project_mixotics.srv import VerifyInstr, VerifyInstrResponse
from final_project_mixotics.srv import PourInstr, PourInstrRequest
from final_project_mixotics.srv import SetInstr, SetInstrRequest
from final_project_mixotics.srv import ConfirmOrder, ConfirmOrderRequest
from menu_utilities.enum_defs import InstrEnum, StoreRoomEnum
from menu_utilities.menu_parser import parse_menu_xml
# Python imports


# 3rd-party imports
import rospy

class OrderHandler:
    """
    ROS Node responsible for receiving customer orders, translating them into
    high-level commands for the robot, and passing commands to the robot. The 
    node also sorts command order for effciency, validates orders from 
    customers, and track status of orders

    SERVICES:
        process_order Order

        update_inventory InventoryUpdate

        verify_instr VerifyInstr

    CLIENTS:
        grab_instr SetInstr

        pour_instr PourInstr

        release_instr SetInstr

        confirm_order ConfirmOrder

    PARAMS:
        + filepath menu.xml ~ filepath to the current menu configuration file.
            The default is the 'config/menu.xml'
    """
    def __init__(self):
        """
        Constructor of ROS Node OrderHandler class. Creates all 3 services, 
        client, order trackers, and internal varibles
        
        Public member:
        filepath menu_path: Filepath to menu configuration
        """
        # init node
        rospy.init_node("order_handler")
        # Grab Parameters
        self.menu_path = rospy.get_param("/mixotics/menu_path", "/config/menu.xml")
        # Set up services
        self._order_service = rospy.Service('process_order', Order, self._handle_order_service)
        self._invUp_service = rospy.Service('update_inventory', InventoryUpdate, self._handle_invUp_service)
        self._verify_service = rospy.Service('verify_instr', VerifyInstr, self._handle_verify_service)
        # Set up clients
        self._grab_client = rospy.ServiceProxy('grab_instr', SetInstr)
        self._pour_client = rospy.ServiceProxy('pour_instr', PourInstr)
        self._release_client = rospy.ServiceProxy('release_instr', SetInstr)
        self._confirm_order_client = rospy.ServiceProxy('confirm_order', ConfirmOrder)
        # Parse Menu file
        self._menu_dict = parse_menu_xml(self.menu_path)
        # Build StoreRoom 
        self._storeroom = {}
        for item in self._menu_dict.keys():
            for ingredient in item.ingredients:
                if ingredient.value not in self._storeroom.keys():
                    self._storeroom[ingredient.value] = True
        # Init Instruction Queue
        self._instr_queue = []
        # Init Active Instruction
        self._active_instr = None
        self._active_complete = False
        # Init New_Orders Queue 
        self._new_orders = []
        self._new_order_num = 1 # Start orders at 1
        self._ORDER_LIMIT = 100 # Max number of simulatanous orders
        
        # Set up run rate and main function
        self._RATE = 20 # in Hz
        self._time_delta = 1./self._RATE
        rospy.Timer(rospy.Duration(self._time_delta), self.main_loop)
        rospy.spin()


    def _handle_order_service(self, req):
        """
        Validate new order and return order num
        TODO:Better Doc
        """
        valid_order = True
        error_str = ""
        for order in req.orders:
            if order not in self._menu_dict.keys():
                valid_order = False
                error_str += f"Drink {order} is not on menu\n"
                continue
            order_item = self._menu_dict[order]
            for ingredient in order_item.ingredients:
                if not self._storeroom[ingredient.value]:
                    valid_order = False
                    error_str += f"Drink {order} is not available, we are out of {ingredient}!\n"
        
        if valid_order:
            order_num = self._new_order_num
            self._new_order_num = (self._new_order_num  % self._ORDER_LIMIT) + 1
            msg = f"Thank you for ordering! Your order number is {order_num}"
            self._new_orders.append((order_num, req.orders))
            return OrderResponse(order_num=order_num, msg=msg)
        else:
            return OrderResponse(order_num=0, msg=error_str)


    def _handle_invUp_service(self, req):
        """
        Updates availability of ingredient
        TODO: Better Doc
        """
        self._storeroom[req.ingredient] = req.available
        return InventoryUpdateRepsonse()

    def _handle_verify_service(self, req):
        """
        Verifies if instruction was done correctly
        """
        pass

    def _send_grab(self, instr_id, instr):
        """
        Request robot grab ingredient
        """
        req = SetInstr(instr_id=instr_id,
                       ingredient_enum=instr[1].value)
        rospy.wait_for_service("grab_instr")
        try:
            self._grab_client(req)
        except rospy.ServiceException as e:
            print(f"Can't talk to robot")
            rospy.logerr(e)

    def _send_pour(self, instr_id, instr):
        """
        Request robot to pour ingredient into cup
        """
        rospy.wait_for_service("pour_instr")
        req = PourInstr(instr_id=instr_id,
                        cup_id=instr[1],
                        amount_ml=instr[2])
        try:
            self._pour_client(req)
        except rospy.ServiceException as e:
            print(f"Can't talk to robot")
            rospy.logerr(e)
    
    def _send_release(self, instr_id, instr):
        """
        Request robot to place ingredient back
        """
        req = SetInstr(instr_id=instr_id,
                       ingredient_enum = instr[1].value)
        rospy.wait_for_service("release_instr")
        try:
            self._release_client(req)
        except rospy.ServiceException as e:
            print(f"Can't talk to robot")
            rospy.logerr(e)

    def main_loop(self):
        """
        Main Execution loop TODO:Better Doc
        """
        # Check if new_order is in
        if len(self._new_orders) > 0:
            # if new_order, process order queue
            self._instr_queue = self._parse_orders()
        # Check if active_order doesn't exist or active_order complete
        # It true, set and send new active order
        if self._active_instr is None or self._active_complete:
            if len(self._instr_queue) > 0:
                instr_id, self._active_instr = self._instr_queue.pop(0)
                self._active_complete = False
                if self._active_instr[0] == InstrEnum.GRAB:
                    self._send_grab(instr_id, self._active_instr)
                elif self._active_instr[0] == InstrEnum.POUR:
                    self._send_pour(instr_id, self._active_instr)
                elif self._active_instr[0] == InstrEnum.RELEASE:
                    self._send_release(instr_id, self._active_instr)
                elif self._active_instr[0] == InstrEnum.DELIVERY:
                    # Check if order is done
                    pass
                else:
                    # Actions we currently don't support go here
                    pass

        # If done, check order num is served
        # TODO: If order num is done, announce order up
        pass


#Activate 'order_handler' node
def main():
    """
    Activation function for order handler
    """
    order_handler = OrderHandler()

# Main Execution loop
if __name__ == "__main__":
    try:
        main()
    #If something kills this node, have it die
    except rospy.ROSInterruptException:
        pass