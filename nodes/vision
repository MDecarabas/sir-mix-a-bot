#!/usr/bin/env python

import rospy
import cv2
from sensor_msgs.msg import Image, CameraInfo
from geometry_msgs.msg import TransformStamped
from cv_bridge import CvBridge, CvBridgeError
import numpy as np
import pyrealsense2 as rs
import tf2_ros


class Vision:
    
    def __init__(self):
        self.sub_color = rospy.Subscriber('/camera/color/image_raw', Image, self.color_callback)
        self.sub_depth = rospy.Subscriber('/camera/aligned_depth_to_color/image_raw', Image, self.depth_callback)
        self.sub_intr = rospy.Subscriber('/camera/depth/camera_info', CameraInfo, self.intr_callback)
        self.camera_broadcaster = tf2_ros.TransformBroadcaster()
        self.bottle_broadcaster = tf2_ros.TransformBroadcaster()
        self.bridge = CvBridge()
        self.intrinsics = None
        self.color_image = None
        self.depth_image = None
        self.r = rospy.Rate(100)


    def get_depth(self, x, y, depth_image):
        dim = depth_image.shape
        if dim[1]-x < 5:
            if dim[0]-y < 5:
                depth = depth_image[y-(dim[0]-y):y+(dim[0]-y), x-(dim[1]-x):x+(dim[1]-x)]
            else:
                depth = depth_image[y-5:y+5, x-(dim[1]-x):x+(dim[1]+x)]
        elif dim[0]-y < 5:
            depth = depth_image[y-(dim[0]-y):y+(dim[0]-y), x-5:x+5]
        else:
            depth = depth_image[y-5:y+5, x-5:x+5]

        depth = np.average(depth)
        return depth        

    def get_position(self, color_image, depth_image, intrinsics):
        try:
            hsv_image = cv2.cvtColor(color_image, cv2.COLOR_BGR2HSV)
        except:
            return False

        l_blue = np.array([15, 225, 20])
        u_blue = np.array([35, 255, 255])

        mask = cv2.inRange(hsv_image, l_blue, u_blue)

        res = cv2.bitwise_and(color_image, color_image, mask=mask)

        kernel = np.ones((5, 5), np.uint8)
        erode = cv2.erode(res, kernel, iterations = 1)
        dilate = cv2.dilate(erode, kernel, iterations = 1)

        contours = cv2.findContours(mask, cv2.RETR_TREE, cv2.CHAIN_APPROX_SIMPLE)[0]

        if len(contours) > 0:
            c_max = max(contours, key=cv2.contourArea)
            m = cv2.moments(c_max)
            cx = int(m['m10']/(m['m00']+ 0.00001))
            cy = int(m['m01']/(m['m00']+ 0.00001))
            centroid_list = []
            if len(centroid_list) > 10:
                del centroid_list[0]
                centroid_list.append((cx, cy))
            else:
                centroid_list.append((cx, cy))
            cv2.drawContours(dilate, c_max, -1, (0, 255, 0), 8)
            cv2.circle(dilate, (cx, cy), 7, (255, 255, 255), 2)

            depth = self.get_depth(cx, cy, depth_image)

            point = rs.rs2_deproject_pixel_to_point(intrinsics, [cx, cy], depth)

            bottle_pos = [p/1000 for p in point]
            self.show_image(dilate, 'HSV')
            return bottle_pos
        
        else:
            self.show_image(dilate, 'HSV')
            return False

            # # position of centroid in real world wrt camera
            # # [x, y, z], with z being depth
            # # from camera's perspective, left is +, up is +, 
            # pos = [-point[0], -point[1], point[2]]
            # rospy.logerr(pos)

    def broadcast(self, xyz):
        camera_bottle_tf = TransformStamped()

        # generate transform
        camera_bottle_tf.header.stamp = rospy.Time.now()
        camera_bottle_tf.header.frame_id = 'bottle_frame'
        camera_bottle_tf.child_frame_id = 'camera_color_optical_frame'

        # adjust to center
        camera_bottle_tf.transform.translation.x = xyz[0]
        camera_bottle_tf.transform.translation.y = xyz[1]
        camera_bottle_tf.transform.translation.z = xyz[2]

        # use quaternion values
        camera_bottle_tf.transform.rotation.x = 0
        camera_bottle_tf.transform.rotation.y = 0
        camera_bottle_tf.transform.rotation.z = 0
        camera_bottle_tf.transform.rotation.w = 1

        self.bottle_broadcaster.sendTransform(camera_bottle_tf)

    def color_callback(self, img):
        try:
            color_image = self.bridge.imgmsg_to_cv2(img, 'passthrough')
        except CvBridgeError as e:
            rospy.logerr('CvBridge Error: {0}'.format(e))
        self.color_image = color_image
        
    def depth_callback(self, img):
        try:
            depth_image = self.bridge.imgmsg_to_cv2(img, 'passthrough')
        except CvBridgeError as e:
            rospy.logerr('CvBridge Error: {0}'.format(e))
        self.depth_image = depth_image

    def intr_callback(self, intr):
        intrinsics = rs.intrinsics()
        intrinsics.width = intr.width
        intrinsics.height = intr.height
        intrinsics.ppx = intr.K[2]
        intrinsics.ppy = intr.K[5]
        intrinsics.fx = intr.K[0]
        intrinsics.fy = intr.K[4]
        intrinsics.model = rs.distortion.none
        intrinsics.coeffs = [i for i in intr.D]
        self.intrinsics = intrinsics
        
    def show_image(self, img, img_name):
        cv2.namedWindow(img_name, 1)
        cv2.imshow(img_name, img)
        cv2.waitKey(3)

def main():
    """ The main() function. """
    rospy.init_node('vision')
    v = Vision()
    while not rospy.is_shutdown():
        pos = v.get_position(v.color_image, v.depth_image, v.intrinsics)
        if pos != False:
            v.broadcast(pos)
        else:
            pass
        v.r.sleep()

if __name__ == '__main__':
    try:
        main()
    except rospy.ROSInterruptException:
        pass