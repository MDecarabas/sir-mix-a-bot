#! usr/bin/env python

from rosgraph.roslogging import RospyLogger
import rospy
import moveit_commander
import actionlib
from moveit_msgs.msg import MoveItErrorCodes
import geometry_msgs.msg
from moveit_commander.conversions import pose_to_list
from rospy.core import rospydebug
from std_srvs.srv import EmptyResponse, Empty, SetBoolResponse, SetBool
#from arm_move.srv import step, follow, reset, resetResponse
from actionlib_msgs.msg import GoalStatusArray
import copy
from franka_gripper.msg import MoveGoal, MoveAction, GraspGoal, GraspAction, GraspEpsilon
from math import pi

class mover():

    '''The mover class contains the functions neccesary for a robot in gazebo to reset, set, and follow waypoints to move a px100 robotic arm.
        The functions inside mover are the init, reset, step, and follow functions. As well besides the 3 main functions it contains functions
        used to add objects in Rviz such as a table and an obstacle, as well as the wait_for_state_update function which aids in the simulation
        not breaking. 
            Typical usage example:
                Mover = mover()
    '''

    def __init__(self):

        '''The init function is neccesary for the mover class to initialize all variables, parameters, and other functions.
            Inside the function the parameters exist, and calls to other functions and services are made so they can be executed in main.
        '''
               
        self.scene = moveit_commander.PlanningSceneInterface()

        group_name = "panda_arm"

        self.move_group = moveit_commander.MoveGroupCommander(group_name)
        self.move_gripper = moveit_commander.MoveGroupCommander('hand')

        planning_frame = self.move_group.get_planning_frame()
        
        #display_trajectory_publisher = rospy.Publisher('/move_group/display_planned_path', moveit_msgs.msg.DisplayTrajectory, queue_size=20)

        self.waypoints = []

        self.box_name = ""

        # self.scene = scene

        self.planning_frame = planning_frame

        self.close = False

        self.add_table()

        self.add_hitBox()

        self.approach()
        
        self.grasp()

        #rospy.sleep(10)

        #print("Time to squeeze")

        #self.squeeze()

        #rospy.sleep(15)
        
        #print ("Time to release")

        #self.gripperopen()


        self.movetopour()

        self.tilt()

        rospy.sleep(3)
        
        self.squeeze()

        self.untilt()
        
        self.grasp()
        
        self.movetodrop()

        rospy.sleep(10)
        
        self.gripperopen()

        rospy.sleep(5)

        self.retract()




    def wait_for_state_update(
            self, box_is_known=False, box_is_attached=False, timeout=4
        ):

            '''The wait_for_state_update function is taken and modified from the interbotix example, and is neccesary for the mover class to be able to intialize its 
               its other functions without breaking the rviz simulation due to prematurely loading parameters. 
               Inside the function calls are made that allow for variables to wait for initialization so that the program runs in an order which does not allow for
               it to break.
            '''

            table_name = self.table_name

            scene = self.scene

            start = rospy.get_time()
            seconds = rospy.get_time()
            while (seconds - start < timeout) and not rospy.is_shutdown():
                # Test if the box is in attached objects
                attached_objects = scene.get_attached_objects([table_name])
                is_attached = len(attached_objects.keys()) > 0

                # Test if the box is in the scene.
                # Note that attaching the box will remove it from known_objects
                is_known = table_name in scene.get_known_object_names()

                # Test if we are in the expected state
                if (box_is_attached == is_attached) and (box_is_known == is_known):
                    return True

                # Sleep so that we give other threads time on the processor
                rospy.sleep(0.1)
                seconds = rospy.get_time()

            # If we exited the while loop without returning then we timed out
            return False
            ## END_SUB_TUTORIAL

    
    def add_hitBox(self, timeout=4):

                '''The add_hitBox function is neccesary for the mover class to add an obstacle within Rviz when intiated.
                   Inside the function the variables for creating an obstacle are defined, this allows for the robot movement 
                   to be limited with respect to the collision box of the robot.  
                '''    

                rospy.sleep(2)

                box_name = self.box_name
                scene = self.scene

                box_pose = geometry_msgs.msg.PoseStamped()
                box_pose.header.frame_id = "world"

                box_pose.pose.position.x = 0.415
                box_pose.pose.position.y = 0
                box_pose.pose.position.z = -0.1
                box_pose.pose.orientation.x = 0
                box_pose.pose.orientation.y = 0
                box_pose.pose.orientation.z = 0
                box_pose.pose.orientation.w = 1

                box_name = "box"
                scene.add_box(box_name, box_pose, size=(0.45, 0.85, 0.19))

                rospy.loginfo('added hitbox')


                self.box_name = box_name
                return self.wait_for_state_update(box_is_known=True, timeout=timeout)

    def add_table(self, timeout=4):

                '''The add_table function is neccesary for the mover class to add a surface within Rviz when intiated.
                   Inside the function the variables for creating a surface are defined so that objects do not fall through 
                   when simulated  and for the robot movement to be limited with respect the table.  
                '''       
                rospy.sleep(2)
                table_name = self.box_name
                scene = self.scene

                table_pose = geometry_msgs.msg.PoseStamped()
                table_pose.header.frame_id = "world"
                table_pose.pose.orientation.w = 1.0
                table_pose.pose.position.x = 0  
                table_pose.pose.position.y = 0
                table_pose.pose.position.z = -0.25
                table_name = "table"
                scene.add_box(table_name, table_pose, size=(2, 2, 0.3))

                self.table_name = table_name
                return self.wait_for_state_update(box_is_known=True, timeout=timeout)


    def readyPos(self):

        '''The readyPos function is neccesary for the mover class to allow for the panda arm to get in its ready position.
           The pre-set ready position makes it easier for a robot to make a plan to go to the location of the ingredients,
           as well as the location of the cups in which it must pour the drink. 
        '''   

        while self.close != True:

            self.desiredIngredient = "ingredient04"
            pos = self.scene.get_object_poses([self.desiredIngredient])

# #X, Y, Z variables need to be changed according to coordinates of bottle of interest
            self.x = pos[self.desiredIngredient].position.x
            self.x = self.x + 0.005
            self.y = pos[self.desiredIngredient].position.y
            self.y = self.y+0.110 #Offset so it does not hit gripper, only works with specific input from objects 
            self.z = pos[self.desiredIngredient].position.z

#Gripper wasn't working last time so it has been commented out

            # self.move_gripper.set_named_target('open')   

            # self.move_gripper.go(wait=True)
            

#Do not change, these are the joints neccesary to grip glass 

            initPos = [-0.157079633, 0.610865, 0.191986, -2.54818071, -1.50098316, 1.44862, 0.785398] #Specified ready position
            
            self.move_group.set_joint_value_target(initPos)

            success, traj_msg, planTime, err = self.move_group.plan()

            if err.val == 1:

                rospy.loginfo("yeeha")

                self.move_group.execute(traj_msg, wait=True)

                # self.move_group.go(wait=True)

            else:
                rospy.loginfo("nooooo")
                pass

            rospy.loginfo("Time to Move")


            self.close = True

        return []

    def readyGrab(self):

        '''The readyGrab function serves the purpose of allowing the arm to shift its pose so that it gets from the initial position 
           to one that is alligned with the desired ingredient it must pick up. Once that is done it removes the desired ingredient
           from the rviz model so that the robot does not detect a collision when grabbing the object. 
        '''   

        current = self.move_group.get_current_pose().pose #Current position for pos shift

        self.current_pose = self.move_group.get_current_pose() #Current position for pos shift
        self.xCurrent = self.current_pose.pose.position.x
        self.yCurrent = self.current_pose.pose.position.y
        self.zCurrent = self.current_pose.pose.position.z

        waypoints = []   

        self.scene.remove_world_object(self.desiredIngredient) #Removes bottle so the motion is not considred a collision

        current.position.x += self.x-self.xCurrent
        waypoints.append(copy.deepcopy(current))
        (plan,fraction) = self.move_group.compute_cartesian_path(waypoints, 0.005, 0.0)
        plan = self.move_group.retime_trajectory(moveit_commander.RobotCommander().get_current_state(), plan, 0.5,0.5)
        self.move_group.execute(plan, wait = True)

        current.position.y += self.y-self.yCurrent
        waypoints.append(copy.deepcopy(current))
        (plan,fraction) = self.move_group.compute_cartesian_path(waypoints, 0.005, 0.0)
        plan = self.move_group.retime_trajectory(moveit_commander.RobotCommander().get_current_state(), plan, 0.5,0.5)
        self.move_group.execute(plan, wait = True)

        return []

    def approach(self):

        '''The approach function combines the readyPos and readyGrab functions into a single service that can be called by the user to
           execute the the functions with respect to a desired ingredient. 
        '''   

        self.readyPos()
        self.readyGrab()

        return []
 
    
    def grasp(self):

        '''The grasp function is the initial soft grasp that the robot executes on a desired ingredient for it to be picked up, which will 
           later be moved to the pouring station where it will pour liquid into requested cups.
        '''

        #Soft initial grasp
        
        client = actionlib.SimpleActionClient('/franka_gripper/grasp', GraspAction)
        client.wait_for_server()
        goal = GraspGoal(width = 0.065, epsilon = GraspEpsilon(0.045, 0.045), speed = 0.005, force = 2)
        client.send_goal(goal)
        client.wait_for_result(rospy.Duration.from_sec(15.0))
        return[]

        
    def movetopour(self):

        '''The movetopour function takes the apriltag coordinates of the drink location on the drink flight and then navigates to an offset 
           from it. This function prepares the robot arm for pouring neccesary ingredients into the right cups to make requested drinks. 
        '''

        #Take apriltag coordinates of the drink location, navigate to an offset from it

        self.desiredLocation = "ingredient01"       #Change ingredient name as required
        pos_pour = self.scene.get_object_poses([self.desiredLocation])

# #X, Y, Z variables need to be changed according to coordinates of bottle of interest
        self.x_pour = pos_pour[self.desiredLocation].position.x
        self.x_pour = self.x_pour-0.025
        self.y_pour = pos_pour[self.desiredLocation].position.y
        self.y_pour = self.y_pour+0.1 #Offset so it does not hit gripper, only works with specific input from objects 
        self.z_pour = pos_pour[self.desiredLocation].position.z
        self.z_pour = self.z_pour+0.282 #Offset on z so we can pour from above
        
        
        current = self.move_group.get_current_pose().pose #Current position for pos shift
        current_pose = self.move_group.get_current_pose() #Current position for pos shift
        xCurrent = current_pose.pose.position.x
        yCurrent = current_pose.pose.position.y
        zCurrent = current_pose.pose.position.z

        self.scene.remove_world_object(self.desiredLocation) #Removes bottle so the motion is not considred a collision
        
        waypoints = []   
        current.position.z += self.z_pour-zCurrent
        waypoints.append(copy.deepcopy(current))
        (plan,fraction) = self.move_group.compute_cartesian_path(waypoints, 0.005, 0.0)
        plan = self.move_group.retime_trajectory(moveit_commander.RobotCommander().get_current_state(), plan, 0.15,0.15)
        self.move_group.execute(plan, wait = True)
     
        waypoints = []       
        current.position.x += self.x_pour-xCurrent
        waypoints.append(copy.deepcopy(current))
        (plan,fraction) = self.move_group.compute_cartesian_path(waypoints, 0.005, 0.0)
        plan = self.move_group.retime_trajectory(moveit_commander.RobotCommander().get_current_state(), plan, 0.25,0.25)
        self.move_group.execute(plan, wait = True)

        waypoints = []
        current.position.y += self.y_pour-yCurrent
        waypoints.append(copy.deepcopy(current))
        (plan,fraction) = self.move_group.compute_cartesian_path(waypoints, 0.005, 0.0)
        plan = self.move_group.retime_trajectory(moveit_commander.RobotCommander().get_current_state(), plan, 0.25,0.25)
        self.move_group.execute(plan, wait = True)

        return []
        
    def squeeze(self):
        
        '''The squeeze function is the hard grasp that the robot executes on a desired ingredient for it to squeeze the liquid into a cup.
        '''

        #Using graspgoal action to squeeze
     
        client = actionlib.SimpleActionClient('/franka_gripper/grasp', GraspAction)
        client.wait_for_server()
        goal = GraspGoal(width = 0.002, epsilon = GraspEpsilon(0.1, 0.1), speed = 3, force = 20)
        client.send_goal(goal)
        client.wait_for_result(rospy.Duration.from_sec(15.0))

        return []
        
    def movetodrop(self):

        '''The movetodrop function takes the apriltag coordinates of the drink location on the drink flight and then navigates to an offset 
           from it. This function prepares the robot arm for pouring neccesary ingredients into the right cups to make requested drinks. 
        '''

        #Return to the initial pickup location
        
        current = self.move_group.get_current_pose().pose #Current position for pos shift
        current_pose = self.move_group.get_current_pose() #Current position for pos shift
        xCurrent = current_pose.pose.position.x
        yCurrent = current_pose.pose.position.y
        zCurrent = current_pose.pose.position.z



        #self.scene.remove_world_object(self.desiredLocation) #Removes bottle so the motion is not considred a collision
        
        waypoints = []       
        current.position.x += self.x-xCurrent
        waypoints.append(copy.deepcopy(current))
        (plan,fraction) = self.move_group.compute_cartesian_path(waypoints, 0.005, 0.0)
        plan = self.move_group.retime_trajectory(moveit_commander.RobotCommander().get_current_state(), plan, 0.25,0.25)
        self.move_group.execute(plan, wait = True)


        waypoints = []
        current.position.y += self.y-yCurrent
        waypoints.append(copy.deepcopy(current))
        (plan,fraction) = self.move_group.compute_cartesian_path(waypoints, 0.005, 0.0)
        plan = self.move_group.retime_trajectory(moveit_commander.RobotCommander().get_current_state(), plan, 0.25,0.25)
        self.move_group.execute(plan, wait = True)
        
        waypoints = []   
        current.position.z += self.z-zCurrent
        waypoints.append(copy.deepcopy(current))
        (plan,fraction) = self.move_group.compute_cartesian_path(waypoints, 0.005, 0.0)
        plan = self.move_group.retime_trajectory(moveit_commander.RobotCommander().get_current_state(), plan, 0.25,0.25)
        self.move_group.execute(plan, wait = True)

        return[]

    def tilt(self):   

        '''The tilt function is responsible for tilting the ingredient a certain amount (experimentally determined), so as to get a steady
           pour into the cup.
        '''   

        #Sends a joint angle command to tilt the gripper before squeezing        
        joint_goal = self.move_group.get_current_joint_values()
        joint_goal[5] = joint_goal[5]+pi/6
        self.move_group.go(joint_goal, wait=True)
        self.move_group.stop()

        return[]

    def untilt(self):    

        '''The untilt function is responsible for lifting the ingredient back to a neutral position so as to stop the flow of liquid into the cup.
        ''' 

        #Untilt to return the bottle to a flat          
        joint_goal = self.move_group.get_current_joint_values()
        joint_goal[5] = joint_goal[5]-pi/6
        self.move_group.go(joint_goal, wait=True)
        self.move_group.stop()

        return[]
        
        
    def gripperopen(self):

        '''The gripperoper function is responsible opening the end-effector gripper to release the cup so that it can it deposit the bottle
           once it has reached the storage area.
        ''' 

        #Open the grippers to deposit the bottle
        
        client3 = actionlib.SimpleActionClient('/franka_gripper/move', MoveAction)
        client3.wait_for_server()
        goal = MoveGoal(width = 0.07, speed = 0.08)
        client3.send_goal(goal)
        client3.wait_for_result(rospy.Duration.from_sec(5.0))

        return[]

    def retract(self):

        '''The retract function is responsible getting back to the initial location to get ready for the next grab & pour sequence.
        ''' 

        #Retract to close to the initial location to get ready for the next pour

        current = self.move_group.get_current_pose().pose #Current position for pos shift
        waypoints = []
        current.position.y += 0.25
        waypoints.append(copy.deepcopy(current))
        (plan,fraction) = self.move_group.compute_cartesian_path(waypoints, 0.005, 0.0)
        plan = self.move_group.retime_trajectory(moveit_commander.RobotCommander().get_current_state(), plan, 0.25)
        self.move_group.execute(plan, wait = True)
        return[]


if __name__ == "__main__":
        rospy.init_node("mover") #Initialize the node
        rospy.wait_for_message('move_group/status', GoalStatusArray)
        Mover = mover()
        #rospy.spin() #Keep running 