#!/usr/bin/env python3

from rosgraph.roslogging import RospyLogger
import rospy
import moveit_commander
import actionlib
from moveit_msgs.msg import MoveItErrorCodes
import geometry_msgs.msg
from moveit_commander.conversions import pose_to_list
from rospy.core import rospydebug
from std_srvs.srv import EmptyResponse, SetBoolResponse, SetBool
from std_msgs.msg import Empty
from final_project_mixotics.srv import SetInstr, PourInstr, VerifyInstr
from actionlib_msgs.msg import GoalStatusArray
import copy
from franka_gripper.msg import MoveGoal, MoveAction, GraspGoal, GraspAction, GraspEpsilon
from math import pi

class mover():

    '''The mover class contains the functions neccesary for a robot in gazebo to reset, set, and follow waypoints to move a px100 robotic arm.
        The functions inside mover are the init, reset, step, and follow functions. As well besides the 3 main functions it contains functions
        used to add objects in Rviz such as a table and an obstacle, as well as the wait_for_state_update function which aids in the simulation
        not breaking. 
            Typical usage example
                Mover = mover()
    '''

    def __init__(self):

        '''The init function is neccesary for the mover class to initialize all variables, parameters, and other functions.
            Inside the function the parameters exist, and calls to other functions and services are made so they can be executed in main.
        '''
               
        self.scene = moveit_commander.PlanningSceneInterface()

        self.c_list = rospy.get_param("/coaster_list", [])

        group_name = "panda_arm"

        self.c_list = rospy.get_param("/coaster_list", [])

        self.move_group = moveit_commander.MoveGroupCommander(group_name)

        self.move_gripper = moveit_commander.MoveGroupCommander('hand')

        self.planning_frame = self.move_group.get_planning_frame()
        
        self.waypoints = [] #Initialize empty waypoint list for moveit trajectory to append

        self.box_name = "" 

        self.close = False #Initialize gripper to be open at the beginning

        self.add_table() #Add table which robot is on

        self.add_hitBox() #Add hitbox so that robot does not accidentally collide with real environment

        self.grab = rospy.Service("grab", SetInstr, self.grab) #Approach to ingredient done

        self.pour = rospy.Service("pour", PourInstr, self.pour) #Takes ingrdient and pours it into cup

        self.stock = rospy.Service("stock", SetInstr, self.stock) #Takes ingrdient back to stocking area and resets arm back into ready position

        self.receive = rospy.ServiceProxy('verify', VerifyInstr) # verification service, return 1 or 0 to see if task executed successfully


    def wait_for_state_update(
            self, box_is_known=False, box_is_attached=False, timeout=4
        ):

            '''The wait_for_state_update function is taken and modified from the interbotix example, and is neccesary for the mover class to be able to intialize its 
               its other functions without breaking the rviz simulation due to prematurely loading parameters. 
               Inside the function calls are made that allow for variables to wait for initialization so that the program runs in an order which does not allow for
               it to break.
            '''

            table_name = self.table_name

            scene = self.scene

            start = rospy.get_time()
            seconds = rospy.get_time()
            while (seconds - start < timeout) and not rospy.is_shutdown():
                # Test if the box is in attached objects
                attached_objects = scene.get_attached_objects([table_name])
                is_attached = len(attached_objects.keys()) > 0

                # Test if the box is in the scene.
                # Note that attaching the box will remove it from known_objects
                is_known = table_name in scene.get_known_object_names()

                # Test if we are in the expected state
                if (box_is_attached == is_attached) and (box_is_known == is_known):
                    return True

                # Sleep so that we give other threads time on the processor
                rospy.sleep(0.1)
                seconds = rospy.get_time()

            # If we exited the while loop without returning then we timed out
            return False
            ## END_SUB_TUTORIAL

    
    def add_hitBox(self, timeout=4):

                '''The add_hitBox function is neccesary for the mover class to add an obstacle within Rviz when intiated.
                   Inside the function the variables for creating an obstacle are defined, this allows for the robot movement 
                   to be limited with respect to the collision box of the robot.  
                '''    

                rospy.sleep(2)

                box_name = self.box_name
                scene = self.scene

                box_pose = geometry_msgs.msg.PoseStamped()
                box_pose.header.frame_id = "world"

                box_pose.pose.position.x = 0.415
                box_pose.pose.position.y = 0
                box_pose.pose.position.z = -0.1
                box_pose.pose.orientation.x = 0
                box_pose.pose.orientation.y = 0
                box_pose.pose.orientation.z = 0
                box_pose.pose.orientation.w = 1

                box_name = "box"
                scene.add_box(box_name, box_pose, size=(0.45, 0.85, 0.19))

                rospy.loginfo('added hitbox')


                self.box_name = box_name
                return self.wait_for_state_update(box_is_known=True, timeout=timeout)

    def add_table(self, timeout=4):

                '''The add_table function is neccesary for the mover class to add a surface within Rviz when intiated.
                   Inside the function the variables for creating a surface are defined so that objects do not fall through 
                   when simulated  and for the robot movement to be limited with respect the table.  
                '''       
                rospy.sleep(2)
                table_name = self.box_name
                scene = self.scene

                table_pose = geometry_msgs.msg.PoseStamped()
                table_pose.header.frame_id = "world"
                table_pose.pose.orientation.w = 1.0
                table_pose.pose.position.x = 0  
                table_pose.pose.position.y = 0
                table_pose.pose.position.z = -0.25
                table_name = "table"
                scene.add_box(table_name, table_pose, size=(2, 2, 0.3))

                self.table_name = table_name
                return self.wait_for_state_update(box_is_known=True, timeout=timeout)


    def readyPos(self, ingredient):

        '''The readyPos function is neccesary for the mover class to allow for the panda arm to get in its ready position.
           The pre-set ready position makes it easier for a robot to make a plan to go to the location of the ingredients,
           as well as the location of the cups in which it must pour the drink. 
        '''   
#To do: int2string
        ingredientString = "ingredient0"+str(ingredient)

        self.desiredIngredient = ingredientString #The ingredient we want to use

        self.desiredLocations = self.c_list    #All ingredients from ROS Param file

        pos = self.scene.get_object_poses([self.desiredIngredient]) #Position of Ingredient we want

        self.pos_pour = self.scene.get_object_poses([self.desiredLocations]) #Position of all possible locations

# #X, Y, Z variables need to be changed according to coordinates of bottle of interest
        self.x = pos[self.desiredIngredient].position.x
        self.x = self.x + 0.005
        self.y = pos[self.desiredIngredient].position.y
        self.y = self.y+0.100     #Offset so it does not hit gripper, only works with specific input from objects 
        self.z = pos[self.desiredIngredient].position.z

#Do not change, these are the joints neccesary to grip glass 

        initPos = [-0.157079633, 0.610865, 0.191986, -2.54818071, -1.50098316, 1.44862, 0.785398] #Specified ready position
            
        self.move_group.set_joint_value_target(initPos)

        success, traj_msg, planTime, err = self.move_group.plan()

        if err.val == 1:

            rospy.loginfo("yeeha")

            self.move_group.execute(traj_msg, wait=True)

                # self.move_group.go(wait=True)

        else:
            rospy.loginfo("nooooo")
            pass

        rospy.loginfo("Time to Move")

        return []

    def readyGrab(self):

        '''The readyGrab function serves the purpose of allowing the arm to shift its pose so that it gets from the initial position 
           to one that is alligned with the desired ingredient it must pick up. Once that is done it removes the desired ingredient
           from the rviz model so that the robot does not detect a collision when grabbing the object. 
        '''   

        current = self.move_group.get_current_pose().pose #Current position for pos shift

        self.current_pose = self.move_group.get_current_pose() #Current position for pos shift
        self.xCurrent = self.current_pose.pose.position.x
        self.yCurrent = self.current_pose.pose.position.y
        self.zCurrent = self.current_pose.pose.position.z

        waypoints = []   

        self.scene.remove_world_object(self.desiredIngredient) #Removes bottle so the motion is not considred a collision

        current.position.x += self.x-self.xCurrent
        waypoints.append(copy.deepcopy(current))
        (plan,fraction) = self.move_group.compute_cartesian_path(waypoints, 0.005, 0.0)
        plan = self.move_group.retime_trajectory(moveit_commander.RobotCommander().get_current_state(), plan, 0.5,0.5)
        self.move_group.execute(plan, wait = True)

        current.position.y += self.y-self.yCurrent
        waypoints.append(copy.deepcopy(current))
        (plan,fraction) = self.move_group.compute_cartesian_path(waypoints, 0.005, 0.0)
        plan = self.move_group.retime_trajectory(moveit_commander.RobotCommander().get_current_state(), plan, 0.25,0.25)
        self.move_group.execute(plan, wait = True)

        return []
 
    
    def grasp(self):

        '''The grasp function is the initial soft grasp that the robot executes on a desired ingredient for it to be picked up, which will 
           later be moved to the pouring station where it will pour liquid into requested cups.
        '''

        #Soft initial grasp
        
        client = actionlib.SimpleActionClient('/franka_gripper/grasp', GraspAction)
        client.wait_for_server()
        goal = GraspGoal(width = 0.065, epsilon = GraspEpsilon(0.045, 0.045), speed = 0.005, force = 2)
        client.send_goal(goal)
        client.wait_for_result(rospy.Duration.from_sec(15.0))
        return[]

        
    def movetopour(self, cup):

        '''The movetopour function takes the apriltag coordinates of the drink location on the drink flight and then navigates to an offset 
           from it. This function prepares the robot arm for pouring neccesary ingredients into the right cups to make requested drinks. 
        '''
#Figure out where to 
        self.desiredLocation = "coaster0"+ str(cup)

# #X, Y, Z variables need to be changed according to coordinates of bottle of interest
        self.x_pour = self.pos_pour[self.desiredLocation].position.x
        self.x_pour = self.x_pour-0.025
        self.y_pour = self.pos_pour[self.desiredLocation].position.y
        self.y_pour = self.y_pour+0.120 #Offset so it does not hit gripper, only works with specific input from objects 
        self.z_pour = self.pos_pour[self.desiredLocation].position.z
        self.z_pour = self.z_pour+0.2 #Offset on z so we can pour from above
        
        
        current = self.move_group.get_current_pose().pose #Current position for pos shift
        current_pose = self.move_group.get_current_pose() #Current position for pos shift
        xCurrent = current_pose.pose.position.x
        yCurrent = current_pose.pose.position.y
        zCurrent = current_pose.pose.position.z

        # self.scene.remove_world_object(self.desiredLocation) #Removes bottle so the motion is not considred a collision
        
        waypoints = []   
        current.position.z += self.z_pour-zCurrent
        waypoints.append(copy.deepcopy(current))
        (plan,fraction) = self.move_group.compute_cartesian_path(waypoints, 0.005, 0.0)
        plan = self.move_group.retime_trajectory(moveit_commander.RobotCommander().get_current_state(), plan, 0.15,0.15)
        self.move_group.execute(plan, wait = True)

        waypoints = []       
        current.position.x += self.x_pour-xCurrent
        waypoints.append(copy.deepcopy(current))
        (plan,fraction) = self.move_group.compute_cartesian_path(waypoints, 0.005, 0.0)
        plan = self.move_group.retime_trajectory(moveit_commander.RobotCommander().get_current_state(), plan, 0.25,0.25)
        self.move_group.execute(plan, wait = True)

        waypoints = []
        current.position.y += self.y_pour-yCurrent
        waypoints.append(copy.deepcopy(current))
        (plan,fraction) = self.move_group.compute_cartesian_path(waypoints, 0.005, 0.0)
        plan = self.move_group.retime_trajectory(moveit_commander.RobotCommander().get_current_state(), plan, 0.25,0.25)
        self.move_group.execute(plan, wait = True)

        self.move_group.shift_pose_target(2, -0.4)
        success, traj_msg, planTime, err = self.move_group.plan()
        self.move_group.execute(traj_msg, wait=True)


        # waypoints = []   
        # current.position.z += -0.04
        # waypoints.append(copy.deepcopy(current))
        # (plan,fraction) = self.move_group.compute_cartesian_path(waypoints, 0.005, 0.0)
        # plan = self.move_group.retime_trajectory(moveit_commander.RobotCommander().get_current_state(), plan, 0.15,0.15)
        # self.move_group.execute(plan, wait = True)

        return []
        
    def squeeze(self, amount):
        
        '''The squeeze function is the hard grasp that the robot executes on a desired ingredient for it to squeeze the liquid into a cup.
        '''

        #Using graspgoal action to squeeze
     
        client = actionlib.SimpleActionClient('/franka_gripper/grasp', GraspAction)
        client.wait_for_server()
        goal = GraspGoal(width = 0.002, epsilon = GraspEpsilon(0.1, 0.1), speed = 100, force = 100)
        client.send_goal(goal)
        client.wait_for_result(rospy.Duration.from_sec(5.0))
        client.cancel_all_goals()

        rospy.sleep(3)

        client.cancel_all_goals()

        rospy.sleep(0.6*amount)
        return []
        
    def movetodrop(self, ingredient):

        '''The movetodrop function takes the apriltag coordinates of the drink location on the drink flight and then navigates to an offset 
           from it. This function prepares the robot arm for pouring neccesary ingredients into the right cups to make requested drinks. 
        '''
        dropLocation = ingredient
        rospy.loginfo("start move2drop")
        #Return to the initial pickup location
        
        current = self.move_group.get_current_pose().pose #Current position for pos shift
        current_pose = self.move_group.get_current_pose() #Current position for pos shift
        xCurrent = current_pose.pose.position.x
        yCurrent = current_pose.pose.position.y
        zCurrent = current_pose.pose.position.z
        rospy.loginfo("end move2drop")


        #self.scene.remove_world_object(self.desiredLocation) #Removes bottle so the motion is not considred a collision


        # waypoints = []   
        # current.position.z += 0.04
        # waypoints.append(copy.deepcopy(current))
        # (plan,fraction) = self.move_group.compute_cartesian_path(waypoints, 0.005, 0.0)
        # plan = self.move_group.retime_trajectory(moveit_commander.RobotCommander().get_current_state(), plan, 0.25,0.25)
        # self.move_group.execute(plan, wait = True)

        current = self.move_group.get_current_pose().pose #Current position for pos shift
        current_pose = self.move_group.get_current_pose() #Current position for pos shift
        xCurrent = current_pose.pose.position.x
        yCurrent = current_pose.pose.position.y
        zCurrent = current_pose.pose.position.z
        rospy.loginfo("end move2drop")

        waypoints = []
        current.position.y += self.y-yCurrent
        waypoints.append(copy.deepcopy(current))
        (plan,fraction) = self.move_group.compute_cartesian_path(waypoints, 0.005, 0.0)
        plan = self.move_group.retime_trajectory(moveit_commander.RobotCommander().get_current_state(), plan, 0.25,0.25)
        self.move_group.execute(plan, wait = True)

        self.tilt()


        current = self.move_group.get_current_pose().pose #Current position for pos shift
        current_pose = self.move_group.get_current_pose() #Current position for pos shift
        xCurrent = current_pose.pose.position.x
        yCurrent = current_pose.pose.position.y
        zCurrent = current_pose.pose.position.z
        
        waypoints = []       
        current.position.x += self.x-xCurrent
        waypoints.append(copy.deepcopy(current))
        (plan,fraction) = self.move_group.compute_cartesian_path(waypoints, 0.005, 0.0)
        plan = self.move_group.retime_trajectory(moveit_commander.RobotCommander().get_current_state(), plan, 0.25,0.25)
        self.move_group.execute(plan, wait = True)




                
        waypoints = []   
        current.position.z += self.z-zCurrent
        waypoints.append(copy.deepcopy(current))
        (plan,fraction) = self.move_group.compute_cartesian_path(waypoints, 0.005, 0.0)
        plan = self.move_group.retime_trajectory(moveit_commander.RobotCommander().get_current_state(), plan, 0.25,0.25)
        self.move_group.execute(plan, wait = True)




        return[]

    def tilt(self):   

        '''The tilt function is responsible for tilting the ingredient a certain amount (experimentally determined), so as to get a steady
           pour into the cup.
        '''   

        #Sends a joint angle command to tilt the gripper before squeezing        
        joint_goal = self.move_group.get_current_joint_values()
        joint_goal[5] = joint_goal[5]+pi/6
        self.move_group.go(joint_goal, wait=True)
        self.move_group.stop()

        return[]

    def untilt(self):    

        '''The untilt function is responsible for lifting the ingredient back to a neutral position so as to stop the flow of liquid into the cup.
        ''' 

        #Untilt to return the bottle to a flat          
        joint_goal = self.move_group.get_current_joint_values()
        joint_goal[5] = joint_goal[5]-pi/6
        self.move_group.go(joint_goal, wait=True)
        self.move_group.stop()

        return[]
        
        
    def gripperopen(self):

        '''The gripperoper function is responsible opening the end-effector gripper to release the cup so that it can it deposit the bottle
           once it has reached the storage area.
        ''' 

        #Open the grippers to deposit the bottle
        rospy.loginfo("start gripOpen")
        client3 = actionlib.SimpleActionClient('/franka_gripper/move', MoveAction)
        client3.wait_for_server()
        goal = MoveGoal(width = 0.080, speed = 0.15)
        client3.send_goal(goal)
        client3.wait_for_result(rospy.Duration.from_sec(25.0))

        # client3.wait_for_result(rospy.Duration.from_sec(5.0))
        rospy.loginfo("end gripOpen")

        return[]

    def retract(self):

        '''The retract function is responsible getting back to the initial location to get ready for the next grab & pour sequence.
        ''' 

        #Retract to close to the initial location to get ready for the next pour
        current = self.move_group.get_current_pose().pose #Current position for pos shift
        waypoints = []
        current.position.y += 0.25
        waypoints.append(copy.deepcopy(current))
        (plan,fraction) = self.move_group.compute_cartesian_path(waypoints, 0.005, 0.0)
        plan = self.move_group.retime_trajectory(moveit_commander.RobotCommander().get_current_state(), plan, 0.25,0.25)
        self.move_group.execute(plan, wait = True)
        return[] 

    def grab(self, data):

        '''The grab function combines the readyPos and readyGrab functions into a single service that can be called by the user to
           execute the functions with respect to a desired ingredient. 
        '''   
        instruct = data.instr_id 
        try:
            ingredient = data.ingredient #Ingredient Number

            self.readyPos(ingredient)

            self.readyGrab()

            self.grasp()      #Initial grasp of ingredient

            err_code = VerifyInstr.SUCCESS
        except:

            err_code = VerifyInstr.FAILURE

        rospy.wait_for_service('verify')
        try:
            self.receive(instruct, err_code)
        except rospy.ServiceException as e:
            print(f"Can't talk to logic")
            rospy.logerr(e)

        return Empty()

    def pour(self, data):

        '''The pour function combines the readyPos and readyGrab functions into a single service that can be called by the user to
           execute the functions with respect to a desired ingredient. 
        ''' 
        instruct = data.instr_id        #We receive we have as response
        try:

            amount = data.amount_ml         # Get from menu

            cup = data.cup_id               #Get from Ryan numbers, take desired location, match

            self.movetopour(cup)

            self.tilt()

        #Adjusting the amount of ml the user receives
        
            self.squeeze(amount)

            self.untilt()
        
            self.grasp()

            err_code = VerifyInstr.SUCCESS

        except: 

            err_code = VerifyInstr.FAILURE

        rospy.wait_for_service('verify')
        try:
            self.receive(instruct, err_code)
        except rospy.ServiceException as e:
            print(f"Can't talk to logic")
            rospy.logerr(e)

        return Empty()

    def stock(self, data):

        '''The stock function combines the readyPos and readyGrab functions into a single service that can be called by the user to
           execute the functions with respect to a desired ingredient. 
        ''' 
        instruct = data.instr_id 
        try:
            ingredient = data.ingredient

            self.movetodrop(ingredient) #ingredient goes in here
        
            self.gripperopen()

            self.retract()

            err_code = VerifyInstr.SUCCESS

        except: 

            err_code = VerifyInstr.FAILURE

        rospy.wait_for_service('verify')
        try:
            self.receive(instruct, err_code)
        except rospy.ServiceException as e:
            print(f"Can't talk to logic")
            rospy.logerr(e)

        return Empty()

if __name__ == "__main__":
        rospy.init_node("mover") #Initialize the node
        rospy.wait_for_message('move_group/status', GoalStatusArray)
        Mover = mover() #Call the node
        rospy.spin() #Keep running forever
